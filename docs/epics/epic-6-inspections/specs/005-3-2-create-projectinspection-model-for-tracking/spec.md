# Specification: Create ProjectInspection Model for Tracking

## Overview

This task implements SQLAlchemy database models for project-level inspection tracking in the Builder Project system. Two new models will be created: `ProjectInspection` to track inspection schedules, status, and outcomes, and `InspectionFinding` to record individual findings discovered during inspections. These models enable consultants to schedule, conduct, and document construction site inspections with proper audit trails.

## Workflow Type

**Type**: feature

**Rationale**: This task introduces entirely new database models and functionality to the system. It's not modifying existing behavior but rather extending the system's capabilities to support inspection tracking, which aligns with a feature workflow.

## Task Scope

### Services Involved
- **backend** (primary) - SQLAlchemy models, database schema, Alembic migration

### This Task Will:
- [ ] Create `ProjectInspection` model with full field definitions and relationships
- [ ] Create `InspectionFinding` model with full field definitions and relationship to ProjectInspection
- [ ] Define two enum types: `InspectionStatus` and `FindingType`
- [ ] Create Alembic migration to generate database tables
- [ ] Establish foreign key relationships to existing models (Project, User, InspectionStageTemplate, ConstructionArea)
- [ ] Implement JSONB fields for flexible data storage (findings, documents, photos, additional_data)

### Out of Scope:
- API endpoints for inspections (separate task)
- Frontend UI for inspection management
- Background tasks or notifications for inspection scheduling
- Integration with InspectionStageTemplate creation (assumes templates already exist)

## Service Context

### Backend Service

**Tech Stack:**
- Language: Python
- Framework: FastAPI
- ORM: SQLAlchemy
- Database: PostgreSQL
- Migration Tool: Alembic
- Key directories: `backend/app/` (application code), `backend/alembic/versions/` (migrations)

**Entry Point:** `backend/app/main.py`

**How to Run:**
```bash
cd backend
uvicorn app.main:app --reload --port 8000
```

**Port:** 8000

**Database Commands:**
```bash
# Create migration
alembic revision --autogenerate -m "Add ProjectInspection and InspectionFinding models"

# Apply migration
alembic upgrade head

# Rollback migration
alembic downgrade -1
```

## Files to Modify

| File | Service | What to Change |
|------|---------|---------------|
| `backend/app/models/__init__.py` | backend | Import and export new models (`ProjectInspection`, `InspectionFinding`) |
| `backend/alembic/versions/[generated].py` | backend | New migration file to create tables (auto-generated by Alembic) |

## Files to Reference

These files show patterns to follow:

| File | Pattern to Copy |
|------|----------------|
| `backend/app/models/user.py` | SQLAlchemy model structure, UUID primary keys, timestamp fields |
| `backend/app/models/*.py` | Foreign key relationship patterns, JSONB field usage |
| `backend/alembic/versions/*.py` | Existing migration file structure and conventions |
| `backend/app/main.py` | Database session configuration and model imports |

## Patterns to Follow

### Model Base Structure

Expected pattern for SQLAlchemy models in this project:

```python
from sqlalchemy import Column, String, DateTime, ForeignKey, Enum as SQLEnum
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from datetime import datetime
import uuid
import enum

class ModelName(Base):
    __tablename__ = 'table_name'

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)

    # Foreign keys
    foreign_id = Column(UUID(as_uuid=True), ForeignKey('other_table.id'), nullable=False)

    # Relationships
    related_object = relationship("RelatedModel", back_populates="reverse_relation")
```

**Key Points:**
- Use `UUID(as_uuid=True)` for primary keys with `uuid.uuid4` default
- Always include `created_at` and `updated_at` timestamp fields
- Use PostgreSQL `JSONB` type for flexible JSON storage
- Define Python `enum.Enum` classes for status/type fields before model definition
- Use `nullable=True` for optional fields, `nullable=False` for required fields

### Enum Definition Pattern

```python
class InspectionStatus(str, enum.Enum):
    NOT_SCHEDULED = "not_scheduled"
    SCHEDULED = "scheduled"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    APPROVED = "approved"
    FAILED = "failed"

# In model:
status = Column(SQLEnum(InspectionStatus), nullable=False, default=InspectionStatus.NOT_SCHEDULED)
```

**Key Points:**
- Inherit from both `str` and `enum.Enum` for JSON serialization compatibility
- Use uppercase enum names with lowercase string values
- Wrap with SQLAlchemy's `SQLEnum()` when using in Column definition

## Requirements

### Functional Requirements

1. **ProjectInspection Model**
   - Description: Track inspection instances for projects with scheduling, status, and outcomes
   - Fields:
     - `id`: UUID primary key
     - `project_id`: Foreign key to Project model (required)
     - `stage_template_id`: Foreign key to InspectionStageTemplate model (required)
     - `area_id`: Foreign key to ConstructionArea model (optional)
     - `inspector_id`: Foreign key to User model (optional, represents consultant)
     - `status`: Enum field (not_scheduled, scheduled, in_progress, completed, approved, failed)
     - `scheduled_date`: Date field (optional)
     - `scheduled_time`: Time field (optional)
     - `completed_at`: DateTime field (optional)
     - `notes`: Text field (optional)
     - `findings`: JSONB field for structured findings data
     - `documents`: JSONB field for document file ID array
     - `additional_data`: JSONB field for extensible metadata
     - `created_at`, `updated_at`: Standard timestamp fields
   - Acceptance: Model can be imported, instantiated, and saved to database without errors

2. **InspectionFinding Model**
   - Description: Record individual findings discovered during inspections
   - Fields:
     - `id`: UUID primary key
     - `inspection_id`: Foreign key to ProjectInspection model (required)
     - `finding_type`: Enum field (pass, minor_issue, major_issue, critical)
     - `description`: Text field (required)
     - `location`: String field (optional)
     - `photos`: JSONB field for photo file ID array
     - `resolution`: Text field (optional)
     - `resolved_at`: DateTime field (optional)
   - Acceptance: Model can be imported, instantiated, related to ProjectInspection, and saved

3. **Database Migration**
   - Description: Alembic migration creates both tables with all constraints
   - Acceptance: `alembic upgrade head` runs without errors and creates tables in PostgreSQL

### Edge Cases

1. **Optional Foreign Keys** - `area_id` and `inspector_id` can be NULL (inspection may not be tied to specific area, or inspector not yet assigned)
2. **Status Transitions** - No database-level constraints on status flow; business logic will enforce valid transitions in API layer
3. **JSONB Fields** - Empty objects/arrays are valid; no schema validation at database level
4. **Timezone Handling** - `completed_at` and `resolved_at` should use UTC; application layer handles timezone conversion

## Implementation Notes

### DO
- Place model files in `backend/app/models/` directory
- Create a new file `backend/app/models/inspection.py` for both models
- Define enum classes at the top of the file before model definitions
- Use `UUID(as_uuid=True)` consistently with existing project patterns
- Set `nullable=False` only for truly required fields
- Add relationships with `back_populates` for bidirectional navigation
- Import models in `backend/app/models/__init__.py` for easy access
- Use `default=datetime.utcnow` (not `datetime.utcnow()`) to avoid same timestamp for all records
- Test migration with `alembic upgrade head` and verify tables exist in PostgreSQL

### DON'T
- Don't add business logic constraints in the model (e.g., status transition validation)
- Don't create separate files for each model (keep both in same file for cohesion)
- Don't hardcode default values for JSONB fields (let them be NULL initially)
- Don't add indexes yet (optimization comes in separate task)
- Don't create API schemas/endpoints in this task (out of scope)

## Development Environment

### Start Services

```bash
# Start PostgreSQL database (via Docker Compose)
docker-compose up -d db

# Start backend service
cd backend
uvicorn app.main:app --reload --port 8000
```

### Service URLs
- Backend API: http://localhost:8000
- API Documentation: http://localhost:8000/docs
- PostgreSQL: localhost:5432 (accessed via connection string)

### Required Environment Variables
```bash
# backend/.env
DATABASE_URL=postgresql://user:password@localhost:5432/builder_db
```

### Database Connection Test
```bash
# Connect to PostgreSQL
docker exec -it builder_program_db_1 psql -U user -d builder_db

# List tables after migration
\dt

# Describe tables
\d project_inspection
\d inspection_finding
```

## Success Criteria

The task is complete when:

1. [ ] `ProjectInspection` model exists in `backend/app/models/inspection.py` with all required fields
2. [ ] `InspectionFinding` model exists in `backend/app/models/inspection.py` with all required fields
3. [ ] `InspectionStatus` and `FindingType` enums are properly defined
4. [ ] Models are imported in `backend/app/models/__init__.py`
5. [ ] Alembic migration successfully created via `alembic revision --autogenerate`
6. [ ] Migration applies cleanly with `alembic upgrade head`
7. [ ] Tables exist in PostgreSQL database and can be queried
8. [ ] Foreign key constraints are properly established
9. [ ] No console errors or warnings during migration
10. [ ] Python can import and instantiate both models without errors

## QA Acceptance Criteria

**CRITICAL**: These criteria must be verified by the QA Agent before sign-off.

### Unit Tests
| Test | File | What to Verify |
|------|------|----------------|
| Model instantiation | `backend/tests/test_models/test_inspection.py` | Both models can be created with valid data |
| UUID generation | `backend/tests/test_models/test_inspection.py` | Primary keys auto-generate UUIDs |
| Enum validation | `backend/tests/test_models/test_inspection.py` | Status and finding_type enums accept only valid values |
| Relationship navigation | `backend/tests/test_models/test_inspection.py` | Can access ProjectInspection from InspectionFinding and vice versa |
| JSONB field storage | `backend/tests/test_models/test_inspection.py` | JSONB fields store and retrieve dict/list data |

### Integration Tests
| Test | Services | What to Verify |
|------|----------|----------------|
| Database persistence | backend ↔ PostgreSQL | Models save to database and can be queried |
| Foreign key constraints | backend ↔ PostgreSQL | Invalid foreign keys raise IntegrityError |
| Timestamp auto-update | backend ↔ PostgreSQL | `updated_at` changes on record modification |

### End-to-End Tests
| Flow | Steps | Expected Outcome |
|------|-------|------------------|
| Migration execution | 1. Run `alembic upgrade head` 2. Check tables in DB | Tables created with correct schema |
| Model import | 1. Python REPL 2. `from app.models import ProjectInspection, InspectionFinding` | No import errors |
| Record creation | 1. Create ProjectInspection 2. Create InspectionFinding 3. Commit to DB | Records persist with correct relationships |

### Database Verification
| Check | Query/Command | Expected |
|-------|---------------|----------|
| Migration exists | `alembic history` | Shows new migration in history |
| Tables created | `\dt` in psql | `project_inspection` and `inspection_finding` tables exist |
| Schema correct | `\d project_inspection` | All columns present with correct types |
| Foreign keys | `\d project_inspection` | FK constraints to project, inspection_stage_template, construction_area, user |
| Enums | `\dT` in psql | `inspectionstatus` and `findingtype` types exist |

### QA Sign-off Requirements
- [ ] All unit tests pass (if tests created)
- [ ] Migration runs cleanly on fresh database
- [ ] Tables exist with correct schema in PostgreSQL
- [ ] Foreign key constraints are properly defined
- [ ] Enum types are created in database
- [ ] Models can be imported without errors
- [ ] No regressions in existing models or migrations
- [ ] Code follows existing project patterns (UUID PKs, timestamps, JSONB usage)
- [ ] No SQL injection vulnerabilities (using SQLAlchemy ORM safely)
- [ ] Migration can be rolled back with `alembic downgrade -1`
